// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://zzbftruhrjfmynhamypk.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Inp6YmZ0cnVocmpmbXluaGFteXBrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mzc5MzI2OTMsImV4cCI6MjA1MzUwODY5M30.v-Oz5lCbpoB9aQvq43WSaZ8DKy1wthSPQYeD8KzixKo";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Helper function to get WebSocket URL for edge functions
export const getEdgeFunctionWebSocketUrl = (functionName: string): string => {
  // Convert the HTTPS URL to WSS
  const wsUrl = SUPABASE_URL.replace('https://', 'wss://');
  return `${wsUrl}/functions/v1/${functionName}`;
};

// Helper to create a WebSocket connection with ping/pong functionality
export const createManagedWebSocket = (url: string, onMessage: (data: any) => void, onError?: (event: Event) => void, onClose?: () => void, onOpen?: () => void) => {
  let ws: WebSocket | null = null;
  let pingInterval: NodeJS.Timeout | null = null;
  let reconnectTimeout: NodeJS.Timeout | null = null;
  
  const connect = () => {
    if (ws) {
      clearPingInterval();
      ws.close();
    }
    
    console.log('Connecting to WebSocket:', url);
    ws = new WebSocket(url);
    
    ws.onopen = () => {
      console.log('WebSocket connection established');
      startPingInterval();
      if (onOpen) onOpen();
    };
    
    ws.onmessage = (event) => {
      try {
        // Handle ping responses
        if (event.data === 'pong') {
          console.log('Received pong from server');
          return;
        }
        
        const data = JSON.parse(event.data);
        onMessage(data);
      } catch (error) {
        console.error('Error processing WebSocket message:', error);
      }
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      if (onError) onError(error);
    };
    
    ws.onclose = () => {
      console.log('WebSocket connection closed, scheduling reconnect');
      clearPingInterval();
      
      // Only attempt to reconnect if the document is visible
      if (document.visibilityState === 'visible') {
        reconnectTimeout = setTimeout(() => {
          console.log('Attempting to reconnect WebSocket');
          connect();
        }, 3000);
      }
      
      if (onClose) onClose();
    };
    
    return ws;
  };
  
  const startPingInterval = () => {
    // Clear any existing interval
    clearPingInterval();
    
    // Send a ping every 30 seconds to keep the connection alive
    pingInterval = setInterval(() => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        console.log('Sending ping to server');
        ws.send(JSON.stringify({ type: 'ping' }));
      }
    }, 30000);
  };
  
  const clearPingInterval = () => {
    if (pingInterval) {
      clearInterval(pingInterval);
      pingInterval = null;
    }
  };
  
  // Handle visibility change to reconnect when the user returns to the tab
  const handleVisibilityChange = () => {
    if (document.visibilityState === 'visible') {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        console.log('Page became visible, reconnecting WebSocket');
        connect();
      }
    } else {
      // If tab is hidden, we can optionally close the connection to save resources
      // Uncomment this if you want to close connection when tab is hidden
      // if (ws) {
      //   ws.close();
      //   ws = null;
      // }
    }
  };
  
  document.addEventListener('visibilitychange', handleVisibilityChange);
  
  // Initial connection
  connect();
  
  // Return methods to control the WebSocket
  return {
    send: (data: any) => {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(typeof data === 'string' ? data : JSON.stringify(data));
      } else {
        console.warn('Cannot send message, WebSocket is not open');
      }
    },
    close: () => {
      document.removeEventListener('visibilitychange', handleVisibilityChange);
      clearPingInterval();
      
      if (reconnectTimeout) {
        clearTimeout(reconnectTimeout);
        reconnectTimeout = null;
      }
      
      if (ws) {
        ws.close();
        ws = null;
      }
    },
    isConnected: () => ws && ws.readyState === WebSocket.OPEN
  };
};
